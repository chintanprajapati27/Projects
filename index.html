<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Break Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            max-width: 600px;
        }
        .break-log-item:nth-child(even) {
            background-color: #f7f9fc;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex items-center justify-center p-2 md:p-4">

    <!-- Main Card Container -->
    <div class="container mx-auto p-6 md:p-8 bg-white rounded-2xl shadow-2xl space-y-6 md:space-y-8 border border-gray-100">
        
        <!-- Header -->
        <header class="text-center">
            <h1 class="text-3xl md:text-4xl font-extrabold text-gray-900">Break Tracker</h1>
            <p class="text-sm text-gray-500 mt-1">Log break times instantly.</p>
        </header>

        <!-- Employee Input & Status -->
        <div class="space-y-4">
            <input type="text" id="employeeNameInput" placeholder="Enter Employee Name" class="w-full p-3 rounded-xl border-2 border-gray-200 focus:outline-none focus:ring-4 focus:ring-blue-100 transition-all text-lg shadow-sm">
            
            <!-- Total Time Display -->
            <div class="bg-blue-600/90 p-6 rounded-xl shadow-lg text-white text-center">
                <h2 class="text-xl font-semibold mb-1 opacity-90">Total Break Duration</h2>
                <p id="totalTime" class="text-5xl font-black tracking-wider">00:00:00</p>
            </div>
        </div>

        <!-- Action Buttons (Responsive) -->
        <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
            <button id="punchInBtn" class="w-full sm:w-1/2 p-5 text-xl text-white font-bold rounded-xl shadow-lg 
                    bg-gradient-to-r from-green-500 to-green-600 
                    hover:from-green-600 hover:to-green-700 
                    transition-all duration-300 transform hover:scale-[1.02] active:scale-[0.98]">
                BREAK START
            </button>
            <button id="punchOutBtn" class="w-full sm:w-1/2 p-5 text-xl text-white font-bold rounded-xl shadow-lg 
                    bg-gradient-to-r from-red-500 to-red-600 
                    hover:from-red-600 hover:to-red-700 
                    transition-all duration-300 transform hover:scale-[1.02] active:scale-[0.98] disabled:opacity-50 disabled:cursor-not-allowed">
                BREAK STOP
            </button>
        </div>

        <!-- Break Logs Section -->
        <div class="p-4 md:p-6 rounded-xl border border-gray-200 bg-gray-50 shadow-inner max-h-80 overflow-y-auto">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Recent Logs</h2>
            <ul id="logList" class="space-y-3 text-gray-700">
                <!-- Break logs will be added here dynamically -->
                <li class="text-center text-gray-400 py-4">No breaks recorded yet.</li>
            </ul>
        </div>
    </div>

    <script>
        const employeeNameInput = document.getElementById('employeeNameInput');
        const punchInBtn = document.getElementById('punchInBtn');
        const punchOutBtn = document.getElementById('punchOutBtn');
        const totalTimeDisplay = document.getElementById('totalTime');
        const logList = document.getElementById('logList');

        // IMPORTANT: Replace this with your Google Apps Script URL
        const appsScriptUrl = 'https://script.google.com/macros/s/AKfycbw21TUzjd1Nra5UL-GpEYOnJgb6IfI2cf6rZGFhv0_Fbo9oMOnXAwJhcTrwIJ0oLzj-uQ/exec'; 

        let breaks = [];
        let punchInTime = null;
        let totalBreakTime = 0;
        let timerInterval = null;
        let lastAccessDate = null; 
        let fifteenMinuteBatchesCompleted = 0; // Tracks the last batch count notified

        /**
         * Checks if a date is from today.
         * @param {Date} date The date to check.
         * @returns {boolean} True if the date is today, false otherwise.
         */
        function isToday(date) {
            const today = new Date();
            return date.getDate() === today.getDate() &&
                   date.getMonth() === today.getMonth() &&
                   date.getFullYear() === today.getFullYear();
        }
        
        /**
         * Requests permission for browser notifications.
         */
        function requestNotificationPermission() {
            if (!("Notification" in window)) {
                console.warn("This browser does not support desktop notification");
            } else if (Notification.permission !== "granted") {
                Notification.requestPermission();
            }
        }

        /**
         * Helper function for ordinal numbers (1st, 2nd, 3rd, etc.)
         */
        function getOrdinal(n) {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return s[(v - 20) % 10] || s[v] || s[0];
        }

        /**
         * Sends a notification for a completed 15-minute break slot.
         */
        function sendBreakNotification(batchNumber) {
            const message = `Break Alert: Your ${batchNumber}${getOrdinal(batchNumber)} 15-minute slot is complete!`;
            
            // 1. In-app Message
            showMessage(message, 'success');

            // 2. Browser Notification
            if (Notification.permission === "granted") {
                new Notification("Break Tracker", {
                    body: message,
                    icon: 'https://placehold.co/60x60/007bff/fff?text=15M' 
                });
            }
        }

        // Load state from localStorage on page load
        document.addEventListener('DOMContentLoaded', () => {
            requestNotificationPermission(); // Ask for notification permission
            
            const savedState = localStorage.getItem('breakTrackerState');
            let employeeName = '';

            if (savedState) {
                const state = JSON.parse(savedState);
                
                // --- Daily Reset Logic ---
                if (state.lastAccessDate) {
                    const savedDate = new Date(state.lastAccessDate);
                    employeeName = state.employeeName || ''; 

                    if (!isToday(savedDate)) {
                        // It's a new day, reset totals and logs
                        breaks = [];
                        totalBreakTime = 0;
                        punchInTime = null;
                        fifteenMinuteBatchesCompleted = 0;
                        showMessage('New Day Detected: Break logs and total time have been reset.', 'success');
                    } else {
                        // Same day, load all previous data
                        breaks = state.breaks;
                        totalBreakTime = state.totalBreakTime;
                        punchInTime = state.punchInTime ? new Date(state.punchInTime) : null;
                    }
                }
                
                // Always set employee name from saved state
                employeeNameInput.value = employeeName || ''; 
            }

            // Set the last access date to now
            lastAccessDate = new Date();
            saveState(); // Save the initial state with the updated access date

            renderLogs();
            updateTotalTimeDisplay();

            // If a punch-in was active, restart the timer
            if (punchInTime) {
                startTimer();
            }
            updateButtonState();
        });

        function saveState() {
            const state = {
                breaks,
                totalBreakTime,
                employeeName: employeeNameInput.value,
                punchInTime: punchInTime ? punchInTime.toISOString() : null,
                lastAccessDate: lastAccessDate ? lastAccessDate.toISOString() : null // Save the last access date
            };
            localStorage.setItem('breakTrackerState', JSON.stringify(state));
        }

        function updateButtonState() {
            if (punchInTime) {
                punchInBtn.disabled = true;
                punchOutBtn.disabled = false;
                punchInBtn.classList.add('opacity-50', 'cursor-not-allowed');
                punchOutBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                punchInBtn.disabled = false;
                punchOutBtn.disabled = true;
                punchInBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                punchOutBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            
            const timeSinceBreakStart = (new Date() - punchInTime) / 1000;
            // Initialize the batch counter based on current elapsed time to handle page refresh
            fifteenMinuteBatchesCompleted = Math.floor(timeSinceBreakStart / 900); // 900 seconds = 15 minutes

            timerInterval = setInterval(() => {
                const elapsed = (new Date() - punchInTime) / 1000;
                // Calculate the true total time based on saved time + current ongoing time
                const newTotalTime = totalBreakTime + elapsed; 
                updateTotalTimeDisplay(newTotalTime);

                // --- 15 Minute Notification Logic ---
                const currentElapsedSincePunchIn = (new Date() - punchInTime) / 1000;
                const currentBatchCount = Math.floor(currentElapsedSincePunchIn / 900); 

                if (currentBatchCount > fifteenMinuteBatchesCompleted) {
                    fifteenMinuteBatchesCompleted = currentBatchCount;
                    sendBreakNotification(currentBatchCount);
                }
            }, 1000);
        }

        function updateTotalTimeDisplay(time = totalBreakTime) {
            const hours = Math.floor(time / 3600);
            const minutes = Math.floor((time % 3600) / 60);
            const seconds = Math.floor(time % 60);

            const format = (num) => num.toString().padStart(2, '0');
            totalTimeDisplay.textContent = `${format(hours)}:${format(minutes)}:${format(seconds)}`;
        }

        function renderLogs() {
            logList.innerHTML = '';
            if (breaks.length === 0) {
                logList.innerHTML = '<li class="text-center text-gray-400 py-4">No breaks recorded yet.</li>';
                return;
            }

            breaks.forEach((b, index) => {
                const li = document.createElement('li');
                li.className = 'break-log-item p-3 rounded-lg flex justify-between items-center text-sm shadow-sm transition-colors duration-150';
                
                const startTime = new Date(b.punchIn).toLocaleTimeString();
                const endTime = new Date(b.punchOut).toLocaleTimeString();
                const duration = formatDuration(b.duration);
                
                li.innerHTML = `
                    <div class="flex flex-col">
                        <span class="font-medium text-gray-900">Break #${breaks.length - index}</span> 
                        <span class="text-xs text-gray-500">From ${startTime} to ${endTime}</span>
                    </div>
                    <span class="text-base text-blue-600 font-bold">${duration}</span>
                `;
                logList.prepend(li); // Add to the top of the list
            });
        }

        function formatDuration(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function showMessage(message, type = 'error') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `fixed bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-xl shadow-xl text-white font-semibold z-50 transition-transform duration-300 transform translate-y-0 ${type === 'error' ? 'bg-red-500' : 'bg-green-500'}`;
            alertDiv.textContent = message;
            document.body.appendChild(alertDiv);
            setTimeout(() => {
                alertDiv.remove();
            }, 4000); // Increased visibility time
        }

        async function logPunchToServer(type) {
            const employeeName = employeeNameInput.value.trim();
            if (!employeeName) {
                showMessage('Please enter an employee name.', 'error');
                return;
            }
            
            const payload = {
                employeeName: employeeName,
                punchType: type === 'IN' ? 'BREAK START' : 'BREAK STOP',
                timestamp: new Date().toISOString(),
                source: 'WebApp'
            };

            // Using fetch with retries (exponential backoff) for robustness
            const maxRetries = 3;
            let currentRetry = 0;
            
            while (currentRetry < maxRetries) {
                try {
                    // Check if the URL is set. The error check is now purely informational.
                    if (!appsScriptUrl || appsScriptUrl.includes('YOUR_GOOGLE_APPS_SCRIPT_URL_HERE')) {
                        showMessage('Google Sheet URL is not configured. Data not sent.', 'error');
                        return;
                    }

                    const response = await fetch(appsScriptUrl, {
                        method: 'POST',
                        mode: 'no-cors', 
                        cache: 'no-cache',
                        headers: {
                            'Content-Type': 'application/json', 
                        },
                        body: JSON.stringify(payload),
                    });
                    
                    // Since mode is 'no-cors', we can't check response.ok, 
                    // we assume success if no network error is thrown.
                    // This is assumed success message, as network failure is handled in catch block
                    if (currentRetry === 0) { 
                        showMessage(`Successfully logged ${payload.punchType} to Google Sheet!`, 'success');
                    }
                    return; // Exit function on success

                } catch (error) {
                    console.error(`Attempt ${currentRetry + 1} failed:`, error);
                    currentRetry++;

                    if (currentRetry === maxRetries) {
                        showMessage(`Failed to connect to Google Sheet after ${maxRetries} tries. Check network and script deployment.`, 'error');
                        return; // Exit function after last failure
                    }

                    // Exponential backoff
                    const delay = Math.pow(2, currentRetry) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        punchInBtn.addEventListener('click', () => {
            const employeeName = employeeNameInput.value.trim();
            if (!employeeName) {
                showMessage('Please enter an employee name.', 'error');
                return;
            }

            if (!punchInTime) {
                punchInTime = new Date();
                logPunchToServer('IN'); 
                startTimer();
                updateButtonState();
                saveState();
            }
        });

        punchOutBtn.addEventListener('click', () => {
            if (punchInTime) {
                const punchOutTime = new Date();
                const duration = (punchOutTime - punchInTime) / 1000;
                breaks.push({
                    punchIn: punchInTime.toISOString(),
                    punchOut: punchOutTime.toISOString(),
                    duration: duration
                });
                totalBreakTime += duration;

                logPunchToServer('OUT');
                
                punchInTime = null;
                clearInterval(timerInterval);
                fifteenMinuteBatchesCompleted = 0; // Reset batch counter
                renderLogs();
                updateTotalTimeDisplay();
                updateButtonState();
                saveState();
            }
        });
        
        updateButtonState();
    </script>
</body>
</html>
